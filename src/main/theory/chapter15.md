# CompletableFuture와 리액티브 프로그래밍의 기초
## 자바에서의 동시성
### 왜 '동시성'인가?
1. 멀티코어 cpu의 등장
2. 대규모 인터넷 기반 앱의 등장

### 자바에선, 어떻게 '동시성'을 구현하는가?
> 책에는 없는 내용이지만, 한번 쭉 정리하자!

#### 1. 멀티프로세싱 
- 프로세스 = 독립된 메모리 공간. IPC가 필요하고, 컨텍스트 스위칭 비용이 큼
- JVM 자체가 이미 프로세스라, 프로세스를 여러 개 굴리는 건 너무 무겁다.
- 따라서 자바에서는 주류가 되지 못함.

#### 2. 멀티쓰레딩 
- 하나의 프로세스 안에서 메모리 공유
- IPC 필요 없으나, 다음과 같은 문제가 있음.
  1) race condition
  2) deadlock
  3) starvation
- 또 여러가지 문제가 있으니...우선 발전 과정에 따라 하나하나 정리해보자!

#### 3. 멀티쓰레딩 (1) : Runnable + Thread 클래스
* 자바 1.0 버전에서 나옴.
* Runnable 클래스 : 쓰레드가 할 일을 정한다.
* Thread 클래스 : 실제 쓰레드
- 인스턴스화를 할 때, Runnable 타입의 객체를 파라미터로 담아 쓰레드로 만든다.
- 이렇게 분리를 하면 쓰레드 재사용, 실행 방식 조정, 상속 문제가 모두 해결되기 때문!

* 예시코드 : 외부 인터넷 주소에서 값을 받아, 다음을 계산!
  * API 안에는 `completed`라는 필드가 있고 true/false의 값이 들어간다.
  * 최종결과 : 성공 요청 수, completed=true 개수
  * 결과(성공 요청 수, completed=true 개수)를 계산하는 로직은 [다음과 같다](../../main/java/part15/section1/ResultCounter.java)
  * 쓰레드 동작은 [다음 코드를 보면 된다.](../../main/java/part15/section1/ApiTask.java)
    * 쓰레드 동작 안에 결과 계산 로직이 포함되어 있다.
  * Main문은 [다음과 같다.](../../main/java/part15/section1/Main.java)

* 문제점 :
  1. Thread를 직접 생성함 -> 비용이 커짐.
  2. 쓰레드 생명주기를 개발자가 직접 관리 -> 제어 포인트가 코드 전체에 흩어짐
  3. 결과(성공 요청 수, completed=true 개수)를 모으는 부분이 뮤택스로 묶여 있음 -> 데드락이 걸릴 수 있음.
  4. 예외 처리(Try-catch) 지옥 -> 어떤 쓰레드에서 실패했는지 원인을 알기 힘듬
  5. 요청이 늘어나면 쓰레드 생성이 폭발 -> 뮤택스/세마포어는 쓰레드들이 한번에 자원에 터치하는 걸 막아줄 뿐, 쓰레드가 태어나는 걸 막을 순 없음

#### 3. 멀티쓰레딩 (2) : Callable + ExecutorService + Future
* Callable / ExecutorService 모두 자바 5에서 등장
* Callable 클래스 : **쓰레드가 할 일을 정하고...추가적인 장점이 있다!**
  * 반환값이 있다! 값을 엄마 쓰레드로 가지고 올 수 있다 = 뮤택스/세마포어를 줄일 수 있다.
  * 예외처리가 가능하다!
* ExecutorService 클래스 : **쓰레드풀이란 걸 사용할 수 있다**
  * 요청이 생길 때마다 쓰레드 만들기 X
  * 쓰레드를 미리 갯수만큼 만들고, 필요할 때 쓰레드를 재활용!
* Future 클래스 : **값을 받아오는 클래스**
  * 다른 쓰레드에서 실행 중이거나, 아직 끝나지 않은 작업의 결과를 현재 쓰레드가 안전하게 다루기 위한 연결고리
  * Callable은 ‘무엇을 반환할지’만 말해줄 뿐 ‘그 반환값을 어떻게 전달할지’는 해결 못 한다.
  * 결국 Callable + Future 조합으로 쓸 수 밖에 없다.

#### 4. 멀티쓰레딩 (3) : CompletableFuture
* Future의 단점 : 블로킹이기 때문에 main thread가 멈춤.
  * 멀티쓰레딩 (1) : 동기 (작업을 메인쓰레드가 책임) + 블로킹 (결과를 받을 때 메인쓰레드가 멈춤)
  * 멀티쓰레딩 (2) : 비동기 (작업을 서브쓰레드가 책임) + 블로킹 (결과를 받을 때 메인쓰레드가 멈춤)
  * 멀티쓰레딩 (3) : 비동기 (작업을 서브쓰레드가 책임) + 논블로킹 (결과를 받을 때 메인쓰레드가 안 멈춤)

```text
* 작업을 메인쓰레드가 책임 : 쓰레드의 시작, 끝을 모두 메인쓰레드가 통제 
* 작업을 서브쓰레드가 책임 : 쓰레드의 끝은 각 서브쓰레드가 통제
```

* CompletableFuture을 쓰면 논블로킹으로 만들 수 있음.
* 비동기 + 논블로킹으로 갈 수록 API 호출이 많을 때 유리하다.

## Executor와 쓰레드 풀
> Executor와 쓰레드 풀을 좀 더 이론적으로 자세히 보자

### 1. ExecutorService로 쓰레드 풀 만들기
```java
import java.util.concurrent.*;
ExecutorService executor = Executors.newFixedThreadPool(n);
// n은 쓰레드 갯수
```

### 2. 쓰레드풀은 항상 좋은가?
- 거의 모든 상황에서 그렇다.
- 하지만, 블로킹 I/O를 사용할 경우 문제가 생긴다.
  - `String data = socket.read();` -> 이런 코드에서 쓰레드는 아무 일을 하지 않는다.
  - 그러나 쓰레드 풀에서는 점유 중이다.
  - 따라서 쓰레드가 고갈된다.

### 3. 쓰레드의 다른 추상화 : 중첩되지 않은 메서드 호출
* [7장의 병렬 스트림 & fork/join 프레임워크](./chapter7.md)를 다시 한번 보자.
  * 쓰레드 `fork()` + `join()` 을 하나의 메서드에서 관리
  * 즉 자식 쓰레드의 생성, 작동, 회수를 모두 엄마 쓰레드가 활용하는 것
  * 위에서 본 것처럼 이러한 방식은 동기(synchronous)라고 한다.
* 반대로 자식 쓰레드가 알아서 작동, 회수를 관리하는 방법도 있다
  * 위에서 본 것처럼 이러한 방식을 비동기(asynchronous)라고 한다.
* 이러한 비동기 멀티쓰레딩은 다음과 같은 위험성이 있다
  1. 데이터 경쟁의 문제 (race condition)
  2. 엄마 쓰레드의 갑작스러운 종료 -> 자식 쓰레드는 어떻게 회수되어야 하는가?
  * 2번 문제를 해결하기 위한 방법으로 자식 쓰레드에 `setDaemon()`을 걸 수 있다.
* 우리가 볼 future, CompletableFuture이 바로 비동기 멀티쓰레딩

### 4. 쓰레드에 무엇을 바라는가?
* 결국 쓰레드에게 바라는 것은 병렬성의 장점을 극대화하도록 프로그램 구조를 만드는것
* 프로그램을 작은 단위로 쪼개는 것

## 동기 API vs 비동기 API
* 함수 f와 g가 있다고 해보자. [(코드)](../../main/java/part15/ApiExample/Functions.java)
```text
public class Functions {
    public static int f(int x) {
        return x * 2;
    }
    public static int g(int x) {
        return x + 1;
    }
}
```
* 함수 f와 g가 
* 먼저 동기 방식의 멀티쓰레딩으로 f + g를 계산한 경우를 보자. [(코드)](../../main/java/part15/ApiExample/ThreadExample.java)
  * 코드가 좀 복잡한 면이 있다.
  * 프로그래머가 직접 자식쓰레드를 제어해야 한다.
* 인제 Future를 
