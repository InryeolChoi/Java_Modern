# CompletableFuture와 리액티브 프로그래밍의 기초
## 자바에서의 동시성
### 왜 '동시성'인가?
1. 멀티코어 cpu의 등장
2. 대규모 인터넷 기반 앱의 등장

### 자바에선, 어떻게 '동시성'을 구현하는가?
#### 1. 멀티프로세싱 
- 프로세스 = 독립된 메모리 공간. IPC가 필요하고, 컨텍스트 스위칭 비용이 큼
- JVM 자체가 이미 프로세스라, 프로세스를 여러 개 굴리는 건 너무 무겁다.
- 따라서 자바에서는 주류가 되지 못함.

#### 2. 멀티쓰레딩 
- 하나의 프로세스 안에서 메모리 공유
- IPC 필요 없으나, 다음과 같은 문제가 있음.
  1) race condition
  2) deadlock
  3) starvation
- 또 여러가지 문제가 있으니...우선 발전 과정에 따라 하나하나 정리해보자!

#### 3. 멀티쓰레딩 (1) : Runnable + Thread 클래스
* 자바 1.0 버전에서 나옴.
* Runnable 클래스 : 쓰레드가 할 일을 정한다.
* Thread 클래스 : 실제 쓰레드
- 인스턴스화를 할 때, Runnable 타입의 객체를 파라미터로 담아 쓰레드로 만든다.
- 이렇게 분리를 하면 쓰레드 재사용, 실행 방식 조정, 상속 문제가 모두 해결되기 때문!

* 예시코드 : 외부 인터넷 주소에서 값을 받아, 다음을 계산!
  * API 안에는 `completed`라는 필드가 있고 true/false의 값이 들어간다.
  * 최종결과 : 성공 요청 수, completed=true 개수
  * 결과(성공 요청 수, completed=true 개수)를 계산하는 로직은 [다음과 같다](../../main/java/part15/section1/ResultCounter.java)
  * 쓰레드 동작은 [다음 코드를 보면 된다.](../../main/java/part15/section1/ApiTask.java)
    * 쓰레드 동작 안에 결과 계산 로직이 포함되어 있다.
  * Main문은 [다음과 같다.](../../main/java/part15/section1/Main.java)

* 문제점 :
  1. Thread를 직접 생성함 -> 비용이 커짐.
  2. 쓰레드 생명주기를 개발자가 직접 관리 -> 제어 포인트가 코드 전체에 흩어짐
  3. 결과(성공 요청 수, completed=true 개수)를 모으는 부분이 뮤택스로 묶여 있음 -> 데드락이 걸릴 수 있음.
  4. 예외 처리(Try-catch) 지옥 -> 어떤 쓰레드에서 실패했는지 원인을 알기 힘듬
  5. 요청이 늘어나면 쓰레드 생성이 폭발 -> 뮤택스/세마포어는 쓰레드들이 한번에 자원에 터치하는 걸 막아줄 뿐, 쓰레드가 태어나는 걸 막을 순 없음

#### 3. 멀티쓰레딩 (2) : Callable + ExecutorService + Future
* Callable / ExecutorService 모두 자바 5에서 등장
* Callable 클래스 : **쓰레드가 할 일을 정하고...추가적인 장점이 있다!**
  * 반환값이 있다! 값을 엄마 쓰레드로 가지고 올 수 있다 = 뮤택스/세마포어를 줄일 수 있다.
  * 예외처리가 가능하다!
* ExecutorService 클래스 : **쓰레드풀이란 걸 사용할 수 있다**
  * 요청이 생길 때마다 쓰레드 만들기 X
  * 쓰레드를 미리 갯수만큼 만들고, 필요할 때 쓰레드를 재활용!
* Future 클래스 : **값을 받아오는 클래스**
  * 다른 쓰레드에서 실행 중이거나, 아직 끝나지 않은 작업의 결과를 현재 쓰레드가 안전하게 다루기 위한 연결고리
  * Callable은 ‘무엇을 반환할지’만 말해줄 뿐 ‘그 반환값을 어떻게 전달할지’는 해결 못 한다.
  * 결국 Callable + Future 조합으로 쓸 수 밖에 없다.

#### 4. 멀티쓰레딩 (3) : CompletableFuture
* Future의 단점 : 블로킹이기 때문에 main thread가 멈춤.
  * 멀티쓰레딩 (1) : 동기 (작업을 메인쓰레드가 책임) + 블로킹 (결과를 받을 때 메인쓰레드가 멈춤)
  * 멀티쓰레딩 (2) : 비동기 (작업을 서브쓰레드가 책임) + 블로킹 (결과를 받을 때 메인쓰레드가 멈춤)
  * 멀티쓰레딩 (3) : 비동기 (작업을 서브쓰레드가 책임) + 블로킹 (결과를 받을 때 메인쓰레드가 안 멈춤)
* CompletableFuture을 쓰면 논블로킹으로 만들 수 있음.

## Executor와 쓰레드 풀
> Executor와 쓰레드 풀을 좀 더 자세히 보자

### 1. ExecutorService로 쓰레드 풀 만들기
```java
import java.util.concurrent.*;
ExecutorService executor = Executors.newFixedThreadPool(n);
```

### 2. 쓰레드풀은 항상 좋은가?
